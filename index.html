<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MyBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="MyBlog">
<meta property="article:author" content="myh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>MyBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MyBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Android-Power-debug%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="myh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Android-Power-debug%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">Android Power debug介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:14:36 / 修改时间：11:19:57" itemprop="dateCreated datePublished" datetime="2020-05-31T11:14:36+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Power/" itemprop="url" rel="index"><span itemprop="name">Power</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-Power-debug介绍"><a href="#Android-Power-debug介绍" class="headerlink" title="Android Power debug介绍"></a>Android Power debug介绍</h1><h2 id="1-Battery-Historian"><a href="#1-Battery-Historian" class="headerlink" title="1 Battery Historian"></a>1 Battery Historian</h2><p>Battery Historian是Google提供的针对Android 5.0及以上系统使用的分析耗电情况的工具。项目源码:<a href="https://github.com/google/battery-historian。" target="_blank" rel="noopener">https://github.com/google/battery-historian。</a></p>
<h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p>可以使用docker来运行Battery Historian，安装docker后，运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -- run -p &lt;port&gt;:9999 gcr.io&#x2F;android-battery-historian&#x2F;stable:3.0 --port 9999</span><br></pre></td></tr></table></figure>

<p>需要选择一个端口号代替<port>。在Ubuntu系统中，使用浏览器打开<code>http://localhost:&lt;port&gt;</code>即可使用Battery Historian，可以看到Battery Historian的开始页：</p>
<p><img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/BatteryHistorian_start.png?ynotemdtimestamp=1590034175113" alt="img"></p>
<h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><p>Battery Historian的输入是bugreport文件，如果是Android 7.0及以上版本的话可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb bugreport bugreport.zip</span><br></pre></td></tr></table></figure>

<p>来获取bugreport文件；如果是Android 6.0及以下版本的话可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb bugreport &gt; bugreport.txt</span><br></pre></td></tr></table></figure>

<p>来获取bugreport文件。一般开始统计数据之前需要使用下面的命令将以前的累积数据清空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys batterystats --reset</span><br></pre></td></tr></table></figure>

<p>使用Battery Historian打开bugreport生成的文件：</p>
<p><img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/20200414160010.png?ynotemdtimestamp=1590034175113" alt="img"></p>
<h4 id="1-2-1-图表"><a href="#1-2-1-图表" class="headerlink" title="1.2.1 图表"></a>1.2.1 图表</h4><p>上图最左侧是metrics，即不同的衡量维度。Add Metrics下拉菜单可以添加更多的metric。把鼠标放在metric的名字上，会显示metric的说明，包括该metric的内容是什么，后面跟着的colorbar不同颜色的含义，如：</p>
<p><img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/BatteryHistorian_metric.png?ynotemdtimestamp=1590034175113" alt="img"></p>
<p>鼠标在colorbar上移动，可以查看在某个特定时间点上metric的详细信息和电池状态，如：</p>
<p><img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/BatteryHistorian_colorbar.png?ynotemdtimestamp=1590034175113" alt="img"></p>
<h4 id="1-2-2-其他信息"><a href="#1-2-2-其他信息" class="headerlink" title="1.2.2 其他信息"></a>1.2.2 其他信息</h4><p>System stats是系统范围的统计，如屏幕亮度等。查看system stats可以配合左边sort apps by的第一个下拉使用，选择排序依据，如按使用电量多少，使用wakelock个数等：</p>
<p><img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/BatteryHistorian_system.png?ynotemdtimestamp=1590034175113" alt="img"></p>
<p>App stats显示某个特定app的信息，可以配合sort apps by的第一个下拉使用，选中要查看的app。选中某个app后，左下方显示了可以查看的信息，该app如果没有相关信息则不显示，一般至少会有一个Misc Summary：</p>
<p><img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/BatteryHistorian_app.png?ynotemdtimestamp=1590034175113" alt="img"></p>
<ul>
<li>Network Infomation：移动数据传输量，后台移动数据传输量，wifi数据传输量，后台wifi数据传输量等。</li>
<li>Wakelocks：app持有的Wakelock信息。</li>
<li>Services：app中服务运行信息。</li>
<li>Processes：app中进程运行信息。</li>
<li>Sensor use：app使用的传感器信息。</li>
</ul>
<p>选中app后，图表信息加黑的metric会针对该app过滤：</p>
<p><img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/BatteryHistorian_app_chart.png?ynotemdtimestamp=1590034175113" alt="img"></p>
<p>可以直观的通过colorbar查看应用持锁时间，处于前台的时间，调度jobscheduler和执行同步任务的频率等。</p>
<p>如果想在上图看到用户空间锁定的可视化信息，需要执行：</p>
<p><img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/BatteryHistorian_userspacelock.png?ynotemdtimestamp=1590034175113" alt="img"></p>
<p><img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/BatteryHistorian_app_chart_2.png?ynotemdtimestamp=1590034175113" alt="img"></p>
<h2 id="2-dumpsys-power"><a href="#2-dumpsys-power" class="headerlink" title="2 dumpsys power"></a>2 dumpsys power</h2><p>PMS提供了dump接口，可以通过dumpsys power查看各种设置和各种信息：</p>
<p><img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/dumppower.png?ynotemdtimestamp=1590034175113" alt="img"></p>
<h2 id="3-adb"><a href="#3-adb" class="headerlink" title="3 adb"></a>3 adb</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys batterystats</span><br><span class="line">adb shell dumpsys batttery</span><br><span class="line">adb shell dumpsys battery unplug</span><br><span class="line">adb shell dumpsys battery set level 1</span><br><span class="line">asb shell settings put global low_power 1</span><br><span class="line">adb shell dumpsys battery reset</span><br></pre></td></tr></table></figure>

<h2 id="4-JobScheduler"><a href="#4-JobScheduler" class="headerlink" title="4 JobScheduler"></a>4 JobScheduler</h2><p>应用可以把不紧急的任务交给JobScheduler，JobScheduler集中处理收到的任务，选择合适的时间，一起执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobSchedulerService</span> <span class="keyword">extends</span> <span class="title">JobService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = JobSchedulerService<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler myHandler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(getApplicationContext(),</span><br><span class="line">                    <span class="string">"JobService task running"</span>, Toast.LENGTH_LONG)</span><br><span class="line">                    .show();</span><br><span class="line">            jobFinished((JobParameters) msg.obj, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">        myHandler.sendMessage(Message.obtain(myHandler, <span class="number">1</span>, params));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/BatteryService%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="myh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/BatteryService%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">BatteryService介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:14:04 / 修改时间：11:30:36" itemprop="dateCreated datePublished" datetime="2020-05-31T11:14:04+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Power/" itemprop="url" rel="index"><span itemprop="name">Power</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BatteryService介绍"><a href="#BatteryService介绍" class="headerlink" title="BatteryService介绍"></a>BatteryService介绍</h1><p>BatteryService主要作用是监听底层battery状态变化，获取最新的battery信息。本文对此流程做个总结梳理。</p>
<img src="https://source.android.com/devices/tech/health/images/health-component-2.png"/>

<h2 id="1-BatteryService注册监听"><a href="#1-BatteryService注册监听" class="headerlink" title="1 BatteryService注册监听"></a>1 BatteryService注册监听</h2><p>代码路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;BatteryService.java</span><br></pre></td></tr></table></figure>

<p>先来看下BatteryService生命周期中的onStart()方法</p>
<h3 id="1-1-onStart"><a href="#1-1-onStart" class="headerlink" title="1.1 onStart"></a>1.1 onStart</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerHealthCallback(); <span class="comment">/*向healthd注册回调*/</span></span><br><span class="line"></span><br><span class="line">    mBinderService = <span class="keyword">new</span> BinderService();</span><br><span class="line">    publishBinderService(<span class="string">"battery"</span>, mBinderService);</span><br><span class="line">    mBatteryPropertiesRegistrar = <span class="keyword">new</span> BatteryPropertiesRegistrar();</span><br><span class="line">    publishBinderService(<span class="string">"batteryproperties"</span>, mBatteryPropertiesRegistrar);</span><br><span class="line">    publishLocalService(BatteryManagerInternal<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalService</span>())</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了注册回调，还向servicemanager注册了两个service：battery和batteryproperties，batteryproperties是提供给BatteryManager获取battery属性的，这两个service实现的功能比较简单，这里就不展开了。</p>
<h3 id="1-2-registerHealthCallback"><a href="#1-2-registerHealthCallback" class="headerlink" title="1.2 registerHealthCallback"></a>1.2 registerHealthCallback</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerHealthCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      traceBegin(<span class="string">"HealthInitWrapper"</span>);</span><br><span class="line">      mHealthServiceWrapper = <span class="keyword">new</span> HealthServiceWrapper();<span class="comment">/*在该类的init方法注册hal回调，详见1.3*/</span></span><br><span class="line">      mHealthHalCallback = <span class="keyword">new</span> HealthHalCallback(); <span class="comment">/*继承自IHealthInfoCallback.Stub，用于hal回调framework。*/</span></span><br><span class="line">      <span class="comment">// IHealth is lazily retrieved.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">/*1.3*/</span></span><br><span class="line">          mHealthServiceWrapper.init(mHealthHalCallback,</span><br><span class="line">                  <span class="keyword">new</span> HealthServiceWrapper.IServiceManagerSupplier() &#123;&#125;,</span><br><span class="line">                  <span class="keyword">new</span> HealthServiceWrapper.IHealthSupplier() &#123;&#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">          Slog.e(TAG, <span class="string">"health: cannot register callback. (RemoteException)"</span>);</span><br><span class="line">          <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">          Slog.e(TAG, <span class="string">"health: cannot register callback. (no supported health HAL service)"</span>);</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          traceEnd();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册hal回调成功后，会主动触发一次hal层的update，回调回来后，更新mHealthInfo，下面是等待该过程执行完毕*/</span></span><br><span class="line">      traceBegin(<span class="string">"HealthInitWaitUpdate"</span>);</span><br><span class="line">      <span class="comment">// init register for new service notifications, and IServiceManager should return the</span></span><br><span class="line">      <span class="comment">// existing service in a near future. Wait for this.update() to instantiate</span></span><br><span class="line">      <span class="comment">// the initial mHealthInfo.</span></span><br><span class="line">      <span class="keyword">long</span> beforeWait = SystemClock.uptimeMillis();</span><br><span class="line">      <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">          <span class="keyword">while</span> (mHealthInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">              Slog.i(TAG, <span class="string">"health: Waited "</span> + (SystemClock.uptimeMillis() - beforeWait) +</span><br><span class="line">                      <span class="string">"ms for callbacks. Waiting another "</span> + HEALTH_HAL_WAIT_MS + <span class="string">" ms..."</span>);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  mLock.wait(HEALTH_HAL_WAIT_MS);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                  Slog.i(TAG, <span class="string">"health: InterruptedException when waiting for update. "</span></span><br><span class="line">                      + <span class="string">" Continuing..."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Slog.i(TAG, <span class="string">"health: Waited "</span> + (SystemClock.uptimeMillis() - beforeWait)</span><br><span class="line">              + <span class="string">"ms and received the update."</span>);</span><br><span class="line">      traceEnd();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>IHealthSupplier()用于获取hal service。</p>
<h3 id="1-3-HealthServiceWrapper-init"><a href="#1-3-HealthServiceWrapper-init" class="headerlink" title="1.3 HealthServiceWrapper.init"></a>1.3 HealthServiceWrapper.init</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Callback callback,</span></span></span><br><span class="line"><span class="function"><span class="params">          IServiceManagerSupplier managerSupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">          IHealthSupplier healthSupplier)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException, NoSuchElementException, NullPointerException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span> || managerSupplier == <span class="keyword">null</span> || healthSupplier == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    IServiceManager manager;</span><br><span class="line"></span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mHealthSupplier = healthSupplier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize mLastService and call callback for the first time (in init thread)</span></span><br><span class="line">    IHealth newService = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/*从hwservicemanager获取hal service，service的名字与底层注册时相关。这里尝试用"default"和"backup"去获取。底层注册的是"default"*/</span></span><br><span class="line">    <span class="keyword">for</span> (String name : sAllInstances) &#123;</span><br><span class="line">        traceBegin(<span class="string">"HealthInitGetService_"</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newService = healthSupplier.get(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">            <span class="comment">/* ignored, handled below */</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            traceEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInstanceName = name;</span><br><span class="line">            mLastService.set(newService);<span class="comment">/*把hal service保存在mLastService*/</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInstanceName == <span class="keyword">null</span> || newService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(String.format(</span><br><span class="line">                <span class="string">"No IHealth service instance among %s is available. Perhaps no permission?"</span>,</span><br><span class="line">                sAllInstances.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这里会调用hal service的注册回调的接口完成注册，具体实现见1.4*/</span></span><br><span class="line">    mCallback.onRegistration(<span class="keyword">null</span>, newService, mInstanceName);</span><br><span class="line"></span><br><span class="line">    /....../</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-HealthHalCallback-onRegistration"><a href="#1-4-HealthHalCallback-onRegistration" class="headerlink" title="1.4 HealthHalCallback.onRegistration"></a>1.4 HealthHalCallback.onRegistration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRegistration</span><span class="params">(IHealth oldService, IHealth newService,</span></span></span><br><span class="line"><span class="function"><span class="params">             String instance)</span> </span>&#123;</span><br><span class="line">/....../</span><br><span class="line">         traceBegin(<span class="string">"HealthRegisterCallback"</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">int</span> r = newService.registerCallback(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">if</span> (r != Result.SUCCESS) &#123;</span><br><span class="line">                 Slog.w(TAG, <span class="string">"health: cannot register callback: "</span> + Result.toString(r));</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// registerCallback does NOT guarantee that update is called</span></span><br><span class="line">             <span class="comment">// immediately, so request a manual update here.</span></span><br><span class="line">             <span class="comment">/*这就是1.2中说的主动调用hal service的update方法，调用该方法最终会携带healthinfo回调回Batteryservice，hal service的update方法还会被内核uevent触发和定时触发，具体后面会进行介绍*/</span></span><br><span class="line">             newService.update();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">             Slog.e(TAG, <span class="string">"health: cannot register callback (transaction error): "</span></span><br><span class="line">                     + ex.getMessage());</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             traceEnd();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>HealthHalCallback实现了HealthServiceWrapper.Callback，同时继承自IHealthInfoCallback.Stub，所以在调用hal的registerCallback方法时，参数传递的是自己。继承自IHealthInfoCallback.Stub需要实现healthInfoChanged接口：</p>
<h3 id="1-5-IHealthInfoCallback-Stub-healthInfoChanged"><a href="#1-5-IHealthInfoCallback-Stub-healthInfoChanged" class="headerlink" title="1.5 IHealthInfoCallback.Stub.healthInfoChanged"></a>1.5 IHealthInfoCallback.Stub.healthInfoChanged</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">healthInfoChanged</span><span class="params">(android.hardware.health.V2_0.HealthInfo props)</span> </span>&#123;</span><br><span class="line">    BatteryService.<span class="keyword">this</span>.update(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递了hal的类型HealthInfo，调用BatteryService的update方法。</p>
<h3 id="1-6-update"><a href="#1-6-update" class="headerlink" title="1.6 update"></a>1.6 update</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(android.hardware.health.V2_0.HealthInfo info)</span> </span>&#123;</span><br><span class="line">    traceBegin(<span class="string">"HealthInfoUpdate"</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceCounter(Trace.TRACE_TAG_POWER, <span class="string">"BatteryChargeCounter"</span>,</span><br><span class="line">            info.legacy.batteryChargeCounter);</span><br><span class="line">    Trace.traceCounter(Trace.TRACE_TAG_POWER, <span class="string">"BatteryCurrent"</span>,</span><br><span class="line">            info.legacy.batteryCurrent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mUpdatesStopped) &#123;</span><br><span class="line">            mHealthInfo = info.legacy;</span><br><span class="line">            <span class="comment">// Process the new values.</span></span><br><span class="line">            processValuesLocked(<span class="keyword">false</span>);</span><br><span class="line">            mLock.notifyAll(); <span class="comment">// for any waiters on new info</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            copy(mLastHealthInfo, info.legacy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processValuesLocked()主要是更新BatteryService中的成员变量，不再赘述。</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/BS_register.png"/>

<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/BS_callback.png"/>

<p>上面是前面代码的时序图，缺失了Health.cpp的update()到handleInfoChanged()的部分，下节介绍。</p>
<h2 id="2-health-2-0"><a href="#2-health-2-0" class="headerlink" title="2 health@2.0"></a>2 <a href="mailto:health@2.0">health@2.0</a></h2><p>healthd是在旧版本中运行的守护进程，负责获取health相关信息并提供给framework。<a href="mailto:health@2.0">health@2.0</a>是android.hardware.health@2.0的缩写，指的是Android9中发布的health HIDL HAL 2.0版本。在最新的AOSP中已出现2.1版本的health HAL，但还没发布到release版本上。</p>
<p>相关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hardware&#x2F;interfaces&#x2F;health&#x2F;2.0&#x2F;default&#x2F;Health.cpp</span><br><span class="line">hardware&#x2F;interfaces&#x2F;health&#x2F;2.0&#x2F;default&#x2F;healthd_common.cpp</span><br><span class="line">hardware&#x2F;interfaces&#x2F;health&#x2F;2.0&#x2F;utils&#x2F;libhealthservice&#x2F;HealthServiceCommon.cpp</span><br><span class="line">system&#x2F;core&#x2F;healthd&#x2F;BatteryMonitor.cpp</span><br><span class="line">device&#x2F;google&#x2F;coral&#x2F;health&#x2F;HealthService.cpp</span><br><span class="line">device&#x2F;google&#x2F;coral&#x2F;health&#x2F;android.hardware.health@2.0-service.coral.rc</span><br></pre></td></tr></table></figure>

<h3 id="2-1-main"><a href="#2-1-main" class="headerlink" title="2.1 main"></a>2.1 main</h3><p>device/google/coral/health/android.hardware.health@2.0-service.coral.rc把service拉起来，对应的Android.bp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;android.hardware.health@2.0-service.coral&quot;,</span><br><span class="line">    init_rc: [&quot;android.hardware.health@2.0-service.coral.rc&quot;],</span><br><span class="line">    proprietary: true,</span><br><span class="line">    relative_install_path: &quot;hw&quot;,</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;HealthService.cpp&quot;,</span><br><span class="line">    ],</span><br><span class="line">    &#x2F;*......*&#x2F;</span><br><span class="line">    static_libs: [</span><br><span class="line">        &quot;android.hardware.health@2.0-impl&quot;,</span><br><span class="line">        &quot;android.hardware.health@1.0-convert&quot;,</span><br><span class="line">        &quot;libhealthservice&quot;,</span><br><span class="line">        &quot;libbatterymonitor&quot;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    shared_libs: [</span><br><span class="line">        &quot;android.hardware.health@2.0&quot;,</span><br><span class="line">    ],</span><br><span class="line">    &#x2F;*......*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码是HealthService.cpp，同时依赖于多个其他目录生成的静态和动态库。入口是HealthService.cpp的main函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*device/google/coral/health/HealthService.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> health_service_main();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设备上可以看到该service：</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/service.png"/>

<p>这部分是vendor-specific的，可以参考hardware/interfaces/health/2.0/README.md</p>
<h3 id="2-2-health-service-main"><a href="#2-2-health-service-main" class="headerlink" title="2.2 health_service_main"></a>2.2 health_service_main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*hardware/interfaces/health/2.0/utils/libhealthservice/HealthServiceCommon.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">health_service_main</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* instance)</span> </span>&#123;</span><br><span class="line">    gInstanceName = instance; <span class="comment">/*传空，默认为null*/</span></span><br><span class="line">    <span class="keyword">if</span> (gInstanceName.empty()) &#123;</span><br><span class="line">        gInstanceName = <span class="string">"default"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    healthd_mode_ops = &amp;healthd_mode_service_2_0_ops;<span class="comment">/*这个变量定义在health_commom.cpp，会经常回调这个ops中的方法*/</span></span><br><span class="line">    LOG(INFO) &lt;&lt; LOG_TAG &lt;&lt; gInstanceName &lt;&lt; <span class="string">": Hal starting main loop..."</span>;</span><br><span class="line">    <span class="keyword">return</span> healthd_main(); <span class="comment">/*见2.3*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件被编译为静态库libhealthservice，具体见相应的Android.bp。主要工作是给health_commom.cpp中的healthd_mode_ops变量赋值，然后调用它的healthd_main()方法。</p>
<h3 id="2-3-healthd-main"><a href="#2-3-healthd-main" class="headerlink" title="2.3 healthd_main"></a>2.3 healthd_main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*hardware/interfaces/health/2.0/default/healthd_common.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">healthd_main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    klog_set_level(KLOG_LEVEL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*调用该方法前，要把healthd_mode_ops初始化*/</span></span><br><span class="line">    <span class="keyword">if</span> (!healthd_mode_ops) &#123;</span><br><span class="line">        KLOG_ERROR(<span class="string">"healthd ops not set, exiting\n"</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = healthd_init();<span class="comment">/*2.4*/</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        KLOG_ERROR(<span class="string">"Initialization failed, exiting\n"</span>);</span><br><span class="line">        exit(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    healthd_mainloop();<span class="comment">/*2.5*/</span></span><br><span class="line">    KLOG_ERROR(<span class="string">"Main loop terminated, exiting\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-healthd-init"><a href="#2-4-healthd-init" class="headerlink" title="2.4 healthd_init"></a>2.4 healthd_init</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*hardware/interfaces/health/2.0/default/healthd_common.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">healthd_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    epollfd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (epollfd == -<span class="number">1</span>) &#123;</span><br><span class="line">        KLOG_ERROR(LOG_TAG, <span class="string">"epoll_create1 failed; errno=%d\n"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    healthd_mode_ops-&gt;init(&amp;healthd_config); <span class="comment">/*2.4.1*/</span></span><br><span class="line">    wakealarm_init(); <span class="comment">/*2.4.2*/</span></span><br><span class="line">    uevent_init(); <span class="comment">/*2.4.3*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-1-healthd-mode-service-2-0-init"><a href="#2-4-1-healthd-mode-service-2-0-init" class="headerlink" title="2.4.1 healthd_mode_service_2_0_init"></a>2.4.1 healthd_mode_service_2_0_init</h4><p>2.2中注册了healthd_mode_ops,所以这里调用的是HealthServiceCommon.cpp中的healthd_mode_service_2_0_init：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">healthd_mode_service_2_0_init</span><span class="params">(struct healthd_config* config)</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; LOG_TAG &lt;&lt; gInstanceName &lt;&lt; <span class="string">" Hal is starting up..."</span>;</span><br><span class="line"></span><br><span class="line">    gBinderFd = setupTransportPolling();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gBinderFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (healthd_register_event(gBinderFd, binder_event))</span><br><span class="line">            LOG(ERROR) &lt;&lt; LOG_TAG &lt;&lt; gInstanceName &lt;&lt; <span class="string">": Register for binder events failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android::sp&lt;IHealth&gt; service = Health::initInstance(config);</span><br><span class="line">    CHECK_EQ(service-&gt;registerAsService(gInstanceName), android::OK)</span><br><span class="line">        &lt;&lt; LOG_TAG &lt;&lt; gInstanceName &lt;&lt; <span class="string">": Failed to register HAL"</span>;</span><br><span class="line"></span><br><span class="line">    LOG(INFO) &lt;&lt; LOG_TAG &lt;&lt; gInstanceName &lt;&lt; <span class="string">": Hal init done"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 setupTransportPolling()定义于system/libhidl/transport/HidlBinderSupport.cpp，gBinderFd即hwbinder驱动fd。</p>
<p>2</p>
<h5 id="healthd-register-event"><a href="#healthd-register-event" class="headerlink" title="healthd_register_event()"></a>healthd_register_event()</h5><p>把一个文件描述符加入到epoll进行监听，epoll_event是对应的监听事件，这里关心的是EPOLLIN，即文件描述符可读，同时传递一个handler指针给epoll_event.dta.ptr，这样事件发生后就知道该如何处理了。关于epoll的使用可以查看相关文档。healthd_register_event()注册的文件描述符会在2.5中loop开启后进行监听，2.4.2和2.4.3加入了另外两个需要监听的文件描述符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">healthd_register_event</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> (*handler)</span><span class="params">(uint32_t)</span>, EventWakeup wakeup) </span>&#123;</span><br><span class="line">    struct epoll_event ev;</span><br><span class="line"></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wakeup == EVENT_WAKEUP_FD) ev.events |= EPOLLWAKEUP;</span><br><span class="line"></span><br><span class="line">    ev.data.ptr = (<span class="keyword">void</span>*)handler;</span><br><span class="line">    <span class="comment">/*epollfd是epoll实体，在2.4中创建的，2.5使用epoll_wait开始监听加入的文件描述符*/</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev) == -<span class="number">1</span>) &#123;</span><br><span class="line">        KLOG_ERROR(LOG_TAG, <span class="string">"epoll_ctl failed; errno=%d\n"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eventct++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3</p>
<h5 id="Health-initInstance"><a href="#Health-initInstance" class="headerlink" title="Health::initInstance()"></a>Health::initInstance()</h5><p>这个接口只是new了Health实例，直接看构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Health::Health(struct healthd_config* c) &#123;</span><br><span class="line">    <span class="comment">// TODO(b/69268160): remove when libhealthd is removed.</span></span><br><span class="line">    healthd_board_init(c);</span><br><span class="line">    battery_monitor_ = std::make_unique&lt;BatteryMonitor&gt;();</span><br><span class="line">    battery_monitor_-&gt;init(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又创建了BatteryMonitor实例，在2.6回调中会用到它。</p>
<h5 id="BatteryMonitor-init"><a href="#BatteryMonitor-init" class="headerlink" title="BatteryMonitor.init()"></a>BatteryMonitor.init()</h5><p>初始化了成员变量：struct healthd_config *mHealthdConfig，这里保存了各个属性读取路径。截取一段battery的路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ANDROID_POWER_SUPPLY_TYPE_BATTERY:</span><br><span class="line">    mBatteryDevicePresent = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHealthdConfig-&gt;batteryStatusPath.isEmpty()) &#123;</span><br><span class="line">        path.clear();</span><br><span class="line">        path.appendFormat(<span class="string">"%s/%s/status"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                          name);</span><br><span class="line">        <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">            mHealthdConfig-&gt;batteryStatusPath = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHealthdConfig-&gt;batteryHealthPath.isEmpty()) &#123;</span><br><span class="line">        path.clear();</span><br><span class="line">        path.appendFormat(<span class="string">"%s/%s/health"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                          name);</span><br><span class="line">        <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">            mHealthdConfig-&gt;batteryHealthPath = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHealthdConfig-&gt;batteryPresentPath.isEmpty()) &#123;</span><br><span class="line">        path.clear();</span><br><span class="line">        path.appendFormat(<span class="string">"%s/%s/present"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                          name);</span><br><span class="line">        <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">            mHealthdConfig-&gt;batteryPresentPath = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHealthdConfig-&gt;batteryCapacityPath.isEmpty()) &#123;</span><br><span class="line">        path.clear();</span><br><span class="line">        path.appendFormat(<span class="string">"%s/%s/capacity"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                          name);</span><br><span class="line">        <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">            mHealthdConfig-&gt;batteryCapacityPath = path;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/battery_prop.png"/>

<p>2.6回调中会用到以上路径</p>
<p>4 registerAsService()，把IHealth注册到hwservicemanager，注册的名字为”default”，上层1.3中使用IHealth.getService()方法获取到该服务（c++客户端使用IHealth::getService()）。</p>
<h4 id="2-4-2-wakealarm-init"><a href="#2-4-2-wakealarm-init" class="headerlink" title="2.4.2 wakealarm_init"></a>2.4.2 wakealarm_init</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wakealarm_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    wakealarm_fd = timerfd_create(CLOCK_BOOTTIME_ALARM, TFD_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (wakealarm_fd == -<span class="number">1</span>) &#123;</span><br><span class="line">        KLOG_ERROR(LOG_TAG, <span class="string">"wakealarm_init: timerfd_create failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (healthd_register_event(wakealarm_fd, wakealarm_event, EVENT_WAKEUP_FD))</span><br><span class="line">        KLOG_ERROR(LOG_TAG, <span class="string">"Registration of wakealarm event failed\n"</span>);</span><br><span class="line"></span><br><span class="line">    wakealarm_set_interval(healthd_config.periodic_chores_interval_fast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>timerfd是linux提供的一组系统调用，用于创建和设置定时器，具体参数含义可以参考linux手册，简单的说就是创建了一个定时器，后面wakealarm_set_interval调用timerfd设置时间的系统调用。超时后，会唤醒系统，调用healthd_register_event传进去的handler：wakealarm_event。</p>
<p>这里的作用是定时上报电池信息，默认为1分钟。</p>
<h4 id="2-4-3-uevent-init"><a href="#2-4-3-uevent-init" class="headerlink" title="2.4.3 uevent_init"></a>2.4.3 uevent_init</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uevent_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    uevent_fd = uevent_open_socket(<span class="number">64</span> * <span class="number">1024</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uevent_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        KLOG_ERROR(LOG_TAG, <span class="string">"uevent_init: uevent_open_socket failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fcntl(uevent_fd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (healthd_register_event(uevent_fd, uevent_event, EVENT_WAKEUP_FD))</span><br><span class="line">        KLOG_ERROR(LOG_TAG, <span class="string">"register for uevent events failed\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建监听kernel uevent事件的套接字，绑定netlink socket，底层通过netlink socket上报uevent的流程见另外一篇文章，这里只需要知道，当底层驱动发送事件时，这里的uevent_fd就变得可读，进而回调使用healthd_register_event注册的uevent_event接口。</p>
<h3 id="2-5-healthd-mainloop"><a href="#2-5-healthd-mainloop" class="headerlink" title="2.5 healthd_mainloop"></a>2.5 healthd_mainloop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">healthd_mainloop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nevents = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        struct epoll_event events[eventct];</span><br><span class="line">        <span class="keyword">int</span> timeout = awake_poll_interval;</span><br><span class="line">        <span class="keyword">int</span> mode_timeout;</span><br><span class="line">		<span class="comment">/*第一次不等待，直接调用periodic_chores（为什么？）,wakealarm_event调用的也是它*/</span></span><br><span class="line">        <span class="comment">/* Don't wait for first timer timeout to run periodic chores */</span></span><br><span class="line">        <span class="keyword">if</span> (!nevents) periodic_chores();</span><br><span class="line"></span><br><span class="line">        healthd_mode_ops-&gt;heartbeat();</span><br><span class="line"></span><br><span class="line">        mode_timeout = healthd_mode_ops-&gt;preparetowait();</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span> || (mode_timeout &gt; <span class="number">0</span> &amp;&amp; mode_timeout &lt; timeout)) timeout = mode_timeout;</span><br><span class="line">        <span class="comment">/*开始等待2.4.1-2.4.3添加的文件描述符*/</span></span><br><span class="line">        nevents = epoll_wait(epollfd, events, eventct, timeout);</span><br><span class="line">        <span class="keyword">if</span> (nevents == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) <span class="keyword">continue</span>;</span><br><span class="line">            KLOG_ERROR(LOG_TAG, <span class="string">"healthd_mainloop: epoll_wait failed\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">/*调用相应的处理函数*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; nevents; ++n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[n].data.ptr) (*(<span class="keyword">void</span> (*)(<span class="keyword">int</span>))events[n].data.ptr)(events[n].events);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上流程对应的时序图如下：</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/20200526175240.png"/>

<h3 id="2-6-回调"><a href="#2-6-回调" class="headerlink" title="2.6 回调"></a>2.6 回调</h3><p>文件描述符可读后的流程就不再贴代码了，就是绕来绕去，最终回调到1.5：</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/1590486822398.png"/>

<p>1 uevent和wakelarm最终都是调用Health.cpp的update()。uevent在调用前会做个过滤，只有uevent（字符串）中包含相应关键字的才是health相关的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">	<span class="comment">/*POWER_SUPPLY_SUBSYSTEM = power_supply*/</span></span><br><span class="line">    <span class="keyword">if</span> (!strcmp(cp, <span class="string">"SUBSYSTEM="</span> POWER_SUPPLY_SUBSYSTEM)) &#123;</span><br><span class="line">        healthd_battery_update();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* advance to after the next \0 */</span></span><br><span class="line">    <span class="keyword">while</span> (*cp++)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设备驱动中有一个名为power_supply的class，sysfs目录也有对应的class：</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/powersupply_class.png"/>

<p>这部分就是监测电量变化电池温度等，属于驱动部分了。</p>
<p>2 Health.cpp的update()转而去调用BatteryMonitor.cpp的update()，在这里通过读取文件的方式完成过对电池属性收集，文件路径的初始化见2.4.1。然后转换成HealthInfo结构体后，由Health.cpp调用注册的callback把该信息传给framework。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Android-Hal%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="myh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Android-Hal%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JobScheduler源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:13:37 / 修改时间：11:32:13" itemprop="dateCreated datePublished" datetime="2020-05-31T11:13:37+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Android-Hal学习"><a href="#Android-Hal学习" class="headerlink" title="Android Hal学习"></a>Android Hal学习</h2><h3 id="1-接口定义和接口实现"><a href="#1-接口定义和接口实现" class="headerlink" title="1 接口定义和接口实现"></a>1 接口定义和接口实现</h3><p>标准AOSP的hal位于hardware/interfaces，在该目录创建目录naruto/1.0/default，为什么叫naruto？因为参考的网上的文章是这样起名字的，<a href="https://www.jianshu.com/p/ca6823b897b5" target="_blank" rel="noopener">参考链接</a>。然后在1.0目录创建INaruto.hal，定义hal提供的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package android.hardware.naruto@1.0;</span><br><span class="line"></span><br><span class="line">interface INaruto &#123;</span><br><span class="line">    helloWorld(string name) generates (string result);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># PACKAGE&#x3D;android.hardware.naruto@1.0</span><br><span class="line"># LOC&#x3D;hardware&#x2F;interfaces&#x2F;naruto&#x2F;1.0&#x2F;default&#x2F;</span><br><span class="line"># make hidl-gen -j64</span><br><span class="line"># hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware&#x2F;interfaces -randroid.hidl:system&#x2F;libhidl&#x2F;transport $PACKAGE</span><br><span class="line"># hidl-gen -o $LOC -Landroidbp-impl -randroid.hardware:hardware&#x2F;interfaces -randroid.hidl:system&#x2F;libhidl&#x2F;transport $PACKAGE</span><br></pre></td></tr></table></figure>

<p>第一个hidl-gen只在default目录生成了INaruto.hal对应的.cpp和.h文件，且两个文件中都有注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; FIXME: most likely delete, this is only for passthrough implementations</span><br><span class="line">&#x2F;&#x2F; extern &quot;C&quot; INaruto* HIDL_FETCH_INaruto(const char* name);</span><br></pre></td></tr></table></figure>

<p>也就是说，生成的文件自动把实现passthrough hal的方式注释掉了，由于该方式已过时，生成的文件中把它注释掉了，如果坚持使用，打开注释即可，参考的链接打开了该注释，实现的是passthrough hal。</p>
<p>第二个hidl-gen命令会在default目录生成一个Android.bp文件。但1.0目录还没有Android.bp文件，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;hardware&#x2F;interfaces&#x2F;update-makefiles.sh</span><br></pre></td></tr></table></figure>

<p>此时1.0目录也会生成对应的Android.bp文件，但比较奇怪的是，打开这个文件，首行的注释说改文件是hidl-gen产生的，额：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589009650704.png" alt="1589009650704"></p>
<p>在来看一下default目录下的Android.bp：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589009737148.png" alt="1589009737148"></p>
<p>这个文件的注释给出了关于passthrough hal和binderlized hal的很有用的说明。首先cc_library_shared表示该模块是一个共享库，属性name给出了共享库的名字，这就说明了passthrough hal最终生成的是一个.so库。注释中说命了把passthrough hal转换成binderlized hal要做的工作：</p>
<ul>
<li>把名字中的-impl改成-service，hal以service的形式提供，同时把cc_library_shared改成cc_binary，也就是说该模块最终不生成共享库了，而是生成一个二进制的可执行文件。</li>
<li>为该模块添加一个.rc文件</li>
<li>删除HIDL_FETCH_I*函数，默认生成的.cpp，.h文件已经把这些函数给注释了。。。</li>
<li>在实例上调用configureRpcThreadpool和registerAsService，后者把服务注册给servicemanager供framework层调用。</li>
</ul>
<p>然后编译模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mmm hardware&#x2F;interfaces&#x2F;naruto&#x2F;1.0&#x2F;default&#x2F;</span><br></pre></td></tr></table></figure>

<p>passthourgh hal是可以Binder化的，所以按照上面的第一条，在Android.bp添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;android.hardware.naruto@1.0-service&quot;,</span><br><span class="line">    defaults: [&quot;hidl_defaults&quot;],</span><br><span class="line">    proprietary: true,</span><br><span class="line">    relative_install_path: &quot;hw&quot;,</span><br><span class="line">    srcs: [&quot;service.cpp&quot;],</span><br><span class="line">    init_rc: [&quot;android.hardware.naruto@1.0-service.rc&quot;],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        &quot;libhidlbase&quot;,</span><br><span class="line">        &quot;libhidltransport&quot;,</span><br><span class="line">        &quot;libutils&quot;,</span><br><span class="line">        &quot;liblog&quot;,</span><br><span class="line">        &quot;android.hardware.naruto@1.0&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建.rc文件和service.cpp,内容分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service naruto_hal_service &#x2F;vendor&#x2F;bin&#x2F;hw&#x2F;android.hardware.naruto@1.0-service</span><br><span class="line">    class hal</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># define LOG_TAG &quot;android.hardware.naruto@1.0-service&quot;</span><br><span class="line"></span><br><span class="line"># include &lt;android&#x2F;hardware&#x2F;naruto&#x2F;1.0&#x2F;INaruto.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;hidl&#x2F;LegacySupport.h&gt;</span><br><span class="line"></span><br><span class="line">using android::hardware::naruto::V1_0::INaruto;</span><br><span class="line">using android::hardware::defaultPassthroughServiceImplementation;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    return defaultPassthroughServiceImplementation&lt;INaruto&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service 的注册使用的是 defaultPassthroughServiceImplementation()方法，而在纯绑定模式中使用</p>
<p>registerAsService()注册service。</p>
<h3 id="2-客户端测试代码"><a href="#2-客户端测试代码" class="headerlink" title="2 客户端测试代码"></a>2 客户端测试代码</h3><p>在hardware/interfaces/naruto/1.0目录创建test目录。并在目录新建client.cpp和Android.bp，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;android&#x2F;hardware&#x2F;naruto&#x2F;1.0&#x2F;INaruto.h&gt;</span><br><span class="line">#include &lt;hidl&#x2F;Status.h&gt;</span><br><span class="line">#include &lt;hidl&#x2F;LegacySupport.h&gt;</span><br><span class="line">#include &lt;utils&#x2F;misc.h&gt;</span><br><span class="line">#include &lt;hidl&#x2F;HidlSupport.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using android::hardware::naruto::V1_0::INaruto;</span><br><span class="line">using android::sp;</span><br><span class="line">using android::hardware::hidl_string;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    android::sp&lt;INaruto&gt; service &#x3D; INaruto::getService();</span><br><span class="line">    if(service &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        printf(&quot;Failed to get service\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    service-&gt;helloWorld(&quot;JayZhang&quot;, [&amp;](hidl_string result) &#123;</span><br><span class="line">                printf(&quot;%s\n&quot;, result.c_str());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;naruto_client&quot;,</span><br><span class="line">    defaults: [&quot;hidl_defaults&quot;],</span><br><span class="line">    relative_install_path: &quot;hw&quot;,</span><br><span class="line">    proprietary: true,</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;client.cpp&quot;,</span><br><span class="line">    ],  </span><br><span class="line">    shared_libs: [</span><br><span class="line">        &quot;liblog&quot;,</span><br><span class="line">        &quot;libhardware&quot;,</span><br><span class="line">        &quot;libhidlbase&quot;,</span><br><span class="line">        &quot;libhidltransport&quot;,</span><br><span class="line">        &quot;libutils&quot;,</span><br><span class="line">        &quot;android.hardware.naruto@1.0&quot;,</span><br><span class="line">    ],  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mmm hardware&#x2F;interfaces&#x2F;naruto&#x2F;1.0&#x2F;test</span><br></pre></td></tr></table></figure>

<p>生成的可执行文件位于：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589181682087.png" alt="1589181682087"></p>
<h3 id="3-遗留问题"><a href="#3-遗留问题" class="headerlink" title="3 遗留问题"></a>3 遗留问题</h3><p>1 上面生成的可执行文件和共享库，在整编时并未打包到镜像，按照网上的教程修改device/google/coral/device.mk添加PRODUCT_PACKAGES也没能生效。</p>
<p>2 直接把so和可执行文件push到相应位置，手动执行可执行文件，service起来后立即就结束了，运行客户端自然也无法获取到service。网上说改xml，修改AOSP中的xml，烧录后也不生效，直接push，也获取不到service。使用纯绑定式的hal，service可以起来，但客户端使用getService()还是无法获取到服务：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589270938049.png" alt="1589270938049"></p>
<h3 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4 参考文档"></a>4 参考文档</h3><p>网上有很多hidl的实践教程，除了前面链接中的，下面的三篇分别给出了纯passthrough，binderlized passthrough和纯binder的实现：</p>
<p><a href="https://chendongqi.me/2019/09/01/hidl-same-process-passthrough/" target="_blank" rel="noopener">passthrough</a></p>
<p><a href="https://chendongqi.me/2019/09/01/hidl-binderizing-passthrough/" target="_blank" rel="noopener">binderlized passthrough</a></p>
<p><a href="https://chendongqi.me/2019/09/08/hidl-binderizd/" target="_blank" rel="noopener">纯binder</a></p>
<p>还有一篇也不错：</p>
<p><a href="[https://ruleizhou.github.io/2019/07/25/Android-Treble-%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84HIDL/](https://ruleizhou.github.io/2019/07/25/Android-Treble-架构下的HIDL/)">Android Treble 架构下的HIDL</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/JobScheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="myh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/JobScheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">JobScheduler源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:13:37 / 修改时间：11:29:33" itemprop="dateCreated datePublished" datetime="2020-05-31T11:13:37+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Power/" itemprop="url" rel="index"><span itemprop="name">Power</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JobScheduler源码分析"><a href="#JobScheduler源码分析" class="headerlink" title="JobScheduler源码分析"></a>JobScheduler源码分析</h1><h2 id="1-JobScheduler启动"><a href="#1-JobScheduler启动" class="headerlink" title="1 JobScheduler启动"></a>1 JobScheduler启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;job&#x2F;JobSchedulerService.java</span><br></pre></td></tr></table></figure>

<h3 id="1-1-构造函数"><a href="#1-1-构造函数" class="headerlink" title="1.1 构造函数"></a>1.1 构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">JobSchedulerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(context);</span><br><span class="line"></span><br><span class="line">      mLocalPM = LocalServices.getService(PackageManagerInternal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      mActivityManagerInternal = Preconditions.checkNotNull(</span><br><span class="line">              LocalServices.getService(ActivityManagerInternal<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//context为systemserver的context</span></span><br><span class="line">      mHandler = <span class="keyword">new</span> JobHandler(context.getMainLooper());</span><br><span class="line">      mConstants = <span class="keyword">new</span> Constants();</span><br><span class="line">      <span class="comment">//监听URI的变化</span></span><br><span class="line">      mConstantsObserver = <span class="keyword">new</span> ConstantsObserver(mHandler);</span><br><span class="line">      mJobSchedulerStub = <span class="keyword">new</span> JobSchedulerStub();</span><br><span class="line"></span><br><span class="line">      mConcurrencyManager = <span class="keyword">new</span> JobConcurrencyManager(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要监控APP idle状态的类，都会实现AppIdleStateChangeListener，</span></span><br><span class="line"><span class="comment">//它是UsageStatsManagerInternal.java的静态内部类。</span></span><br><span class="line">      <span class="comment">//UsageStats是Android P中引入的应用待机群组的功能，这里不展开介绍。</span></span><br><span class="line">      <span class="comment">// Set up the app standby bucketing tracker</span></span><br><span class="line">      mStandbyTracker = <span class="keyword">new</span> StandbyTracker();</span><br><span class="line">      mUsageStats = LocalServices.getService(UsageStatsManagerInternal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      mUsageStats.addAppIdleStateChangeListener(mStandbyTracker);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The job store needs to call back</span></span><br><span class="line">      publishLocalService(JobSchedulerInternal<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalService</span>())</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//见1.1.1</span></span><br><span class="line">      <span class="comment">// Initialize the job store and set up any persisted jobs</span></span><br><span class="line">      mJobs = JobStore.initAndGet(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create the controllers.</span></span><br><span class="line">      mControllers = <span class="keyword">new</span> ArrayList&lt;StateController&gt;();</span><br><span class="line">      mControllers.add(<span class="keyword">new</span> ConnectivityController(<span class="keyword">this</span>));</span><br><span class="line">      mControllers.add(<span class="keyword">new</span> TimeController(<span class="keyword">this</span>));</span><br><span class="line">      mControllers.add(<span class="keyword">new</span> IdleController(<span class="keyword">this</span>));</span><br><span class="line">      mBatteryController = <span class="keyword">new</span> BatteryController(<span class="keyword">this</span>);</span><br><span class="line">      mControllers.add(mBatteryController);</span><br><span class="line">      mStorageController = <span class="keyword">new</span> StorageController(<span class="keyword">this</span>);</span><br><span class="line">      mControllers.add(mStorageController);</span><br><span class="line">      mControllers.add(<span class="keyword">new</span> BackgroundJobsController(<span class="keyword">this</span>));</span><br><span class="line">      mControllers.add(<span class="keyword">new</span> ContentObserverController(<span class="keyword">this</span>));</span><br><span class="line">      mDeviceIdleJobsController = <span class="keyword">new</span> DeviceIdleJobsController(<span class="keyword">this</span>);</span><br><span class="line">      mControllers.add(mDeviceIdleJobsController);</span><br><span class="line">      mControllers.add(<span class="keyword">new</span> QuotaController(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the job store determined that it can't yet reschedule persisted jobs,</span></span><br><span class="line">      <span class="comment">// we need to start watching the clock.</span></span><br><span class="line">      <span class="keyword">if</span> (!mJobs.jobTimesInflatedValid()) &#123;</span><br><span class="line">          Slog.w(TAG, <span class="string">"!!! RTC not yet good; tracking time updates for job scheduling"</span>);</span><br><span class="line">          context.registerReceiver(mTimeSetReceiver, <span class="keyword">new</span> IntentFilter(Intent.ACTION_TIME_CHANGED));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-1-JobStore-initAndGet"><a href="#1-1-1-JobStore-initAndGet" class="headerlink" title="1.1.1 JobStore.initAndGet"></a>1.1.1 JobStore.initAndGet</h4><p>创建单例JobStore，用于维护job scheduler跟踪的jobs列表，同时也负责向磁盘写入和读取jobs功能。</p>
<p>JobStore在构造时，先读取/data/system/job/jobs.xml文件，并创建JobSet，将xml中的job读取到JobSet中。</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/20200525203311.png"/>

<p>JobStore内部定义了一个ReadJobMapFromDiskRunnable，创建它的时候会把自己的成员变量mJobSet传入，在Runnable的run函数中对该JobSet进行填充：</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/20200526115916.png"/>

<p>JobInfo.Builder是用于生成JobInfo的，应用在使用时也是用它来设置job的属性，设置完之后build()。这里JobInfo是JobStatus的成员变量，而JobSet保存JobStatus的二维数组，第一维是uid或者sourceUid，对应JobStatus的callingUid和sourceUid成员变量。callingUid是请求job的包的uid，sourceUid是job执行(?，hosted)的app的uid。查看一下xml中的一个job，它的uid和sourceUid如下：</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/20200526120851.png"/>

<p>整个job存储相关的类图如下：</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/20200526120431.png"/>

<h4 id="1-1-2-StateController"><a href="#1-1-2-StateController" class="headerlink" title="1.1.2 StateController"></a>1.1.2 StateController</h4><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ConnectivityController</td>
<td>注册监听网络连接状态变化</td>
</tr>
<tr>
<td>TimeController</td>
<td>注册监听job时间到期的广播</td>
</tr>
<tr>
<td>IdleController</td>
<td>设备不用/灭屏或dreaming一段时间后认为设备idle</td>
</tr>
<tr>
<td>BatteryController</td>
<td>监听设备是否充电。插上两分钟后认为在充电。</td>
</tr>
<tr>
<td>StorageController</td>
<td>监控设备的存储</td>
</tr>
<tr>
<td>BackgroundJobsController</td>
<td>1 跟踪JobStatus的后台限制比特位，它用于允许免除battery-saver的job运行。2 跟踪AppStateTracker控制的布尔值uid-active。uid-active的jobs可以不用管待机状态限制而运行jobs。</td>
</tr>
<tr>
<td>ContentObserverController</td>
<td>监控内容URI</td>
</tr>
<tr>
<td>DeviceIdleJobsController</td>
<td>设备进入DOZING，对除白名单外的jobs施加限制</td>
</tr>
<tr>
<td>QutoController</td>
<td>对应Android P引入的应用待机分组，不同组的应用拥有不同的配额，允许的Job个数也不同。如果应用在前台，其所有的jobs都允许运行。充电时也不会限制。</td>
</tr>
</tbody></table>
<h3 id="1-2-onBootPhase"><a href="#1-2-onBootPhase" class="headerlink" title="1.2 onBootPhase"></a>1.2 onBootPhase</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void onBootPhase(int phase) &#123;</span><br><span class="line">    if (PHASE_SYSTEM_SERVICES_READY &#x3D;&#x3D; phase) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        1 监听包移除，更改广播，监听移除用户广播</span><br><span class="line">        2 向AMS注册uid的观察</span><br><span class="line">        3 注册thermal callback</span><br><span class="line">        *&#x2F;</span><br><span class="line">    &#125; else if (phase &#x3D;&#x3D; PHASE_THIRD_PARTY_APPS_CAN_START) &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            &#x2F;&#x2F; Let&#39;s go!</span><br><span class="line">            &#x2F;&#x2F;......</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Create the &quot;runners&quot;.</span><br><span class="line">            for (int i &#x3D; 0; i &lt; MAX_JOB_CONTEXTS_COUNT; i++) &#123;</span><br><span class="line">                mActiveServices.add(</span><br><span class="line">                        new JobServiceContext(this, mBatteryStats, mJobPackageTracker,</span><br><span class="line">                                getContext().getMainLooper()));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Attach jobs to their controllers.</span><br><span class="line">            mJobs.forEachJob((job) -&gt; &#123;</span><br><span class="line">                for (int controller &#x3D; 0; controller &lt; mControllers.size(); controller++)&#123;</span><br><span class="line">                    final StateController sc &#x3D; mControllers.get(controller);</span><br><span class="line">                    sc.maybeStartTrackingJobLocked(job, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            &#x2F;&#x2F; GO GO GO!</span><br><span class="line">            mHandler.obtainMessage(MSG_CHECK_JOB).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobServiceContext:真正运行job的地方。</p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8Buevent%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="myh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8Buevent%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Linux设备模型之uevent简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 10:51:31 / 修改时间：10:57:23" itemprop="dateCreated datePublished" datetime="2020-05-31T10:51:31+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux设备模型之uevent简介"><a href="#Linux设备模型之uevent简介" class="headerlink" title="Linux设备模型之uevent简介"></a>Linux设备模型之uevent简介</h2><h3 id="1-Kobject"><a href="#1-Kobject" class="headerlink" title="1 Kobject"></a>1 Kobject</h3><p><strong>kobject</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;include&#x2F;linux&#x2F;kobject.h&gt;</span><br><span class="line">struct kobject &#123;</span><br><span class="line">	const char		*name;</span><br><span class="line">	struct list_head	entry;</span><br><span class="line">	struct kobject		*parent;</span><br><span class="line">	struct kset		*kset;</span><br><span class="line">	struct kobj_type	*ktype;</span><br><span class="line">	struct kernfs_node	*sd; &#x2F;* sysfs directory entry *&#x2F;</span><br><span class="line">	struct kref		kref;</span><br><span class="line">#ifdef CONFIG_DEBUG_KOBJECT_RELEASE</span><br><span class="line">	struct delayed_work	release;</span><br><span class="line">#endif</span><br><span class="line">	unsigned int state_initialized:1;</span><br><span class="line">	unsigned int state_in_sysfs:1;</span><br><span class="line">	unsigned int state_add_uevent_sent:1;</span><br><span class="line">	unsigned int state_remove_uevent_sent:1;</span><br><span class="line">	unsigned int uevent_suppress:1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个kobject都会在“/sys/”文件系统中以目录的形式出现。</p>
<p><strong>kset</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;include&#x2F;linux&#x2F;kobject.h&gt;</span><br><span class="line">struct kset &#123;</span><br><span class="line">	struct list_head list;</span><br><span class="line">	spinlock_t list_lock;</span><br><span class="line">	struct kobject kobj;</span><br><span class="line">	const struct kset_uevent_ops *uevent_ops;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>kset是一个特殊的kobject，也会在“/sys/”文件系统中以目录的形式出现。</p>
<p><strong>ktype</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;include&#x2F;linux&#x2F;kobject.h&gt;</span><br><span class="line">struct kobj_type &#123;</span><br><span class="line">	void (*release)(struct kobject *kobj);</span><br><span class="line">	const struct sysfs_ops *sysfs_ops;</span><br><span class="line">	struct attribute **default_attrs;</span><br><span class="line">	const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);</span><br><span class="line">	const void *(*namespace)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>release：通过该函数，释放kobject的内存空间，或者是包含kobject的数据结构的内存空间，这时应该由它来提供release函数的实现。</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/kset.png"/>

<h3 id="2-uevent"><a href="#2-uevent" class="headerlink" title="2 uevent"></a>2 uevent</h3><p>前面kset结构体中struct kset_uevent_ops是和uevent相关的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;include&#x2F;linux&#x2F;kobject.h&gt;</span><br><span class="line">struct kset_uevent_ops &#123;</span><br><span class="line">	int (* const filter)(struct kset *kset, struct kobject *kobj);</span><br><span class="line">	const char *(* const name)(struct kset *kset, struct kobject *kobj);</span><br><span class="line">	int (* const uevent)(struct kset *kset, struct kobject *kobj,</span><br><span class="line">		      struct kobj_uevent_env *env);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>filter：当任何kobject需要上报uevent时，它所属的kset可以通过该接口过滤，阻止不希望上报的event。</p>
<p>name：返回kset的名称。如果kset没有合法名称，则其下的所有kobject不允许上报uevent。</p>
<p>uevent：当任何kobject需要上报uevent时，它所属的kset可以通过该接口为这些event统一添加环境变量。</p>
<p>lib/kobject_uevent.c提供上报uevent的接口为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * kobject_uevent - notify userspace by sending an uevent</span><br><span class="line"> * ...</span><br><span class="line"> *&#x2F;</span><br><span class="line">int kobject_uevent(struct kobject *kobj, enum kobject_action action)</span><br><span class="line">&#123;</span><br><span class="line">	return kobject_uevent_env(kobj, action, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kobject_uevent_env()的实现比较长，它主要做了：</p>
<ul>
<li>kobj本身或其parent是否从属于某个kset，如果不是，报错返回。</li>
<li>kobj-&gt;uevent_suppress是否为真，为真则忽略所有的uevent并返回。</li>
<li>如果所属kset的kset_uevent_ops不为空且filter函数存在，则使用该函数判断该uevent是否要过滤。</li>
<li>如果所属kset的kset_uevent_ops不为空且name函数存在，则调用该函数获取字符串subsystem的值；否则，kset-&gt;kobj的名字作为subsystem。subsystem不允许为空，否则返回。</li>
<li>分配环境变量struct kobj_uevent_env *env，关于struct kobj_uevent_env的内容如后图所示。</li>
<li>获取该kobject在sysfs中的路径，保存在devpath，如果为空，报错返回。</li>
<li>调用<code>add_uevent_var()</code>接口，把action 类型，devpath，subsystem，接口传进来的envp_ext（如果有）格式化到env buffer中。</li>
<li>更新kobject中状态位信息。</li>
<li>获取SEQNUM，并格式化到env buffer中。</li>
<li>如果定义了CONFIG_NET，最终调用<code>netlink_broadcast_filtered()</code>接口，通过netlink socket广播netlink message。</li>
<li>kernel也可以调用<code>call_usermodehelper_exec()</code>，它把uevent扩展为一个进程，并为每个进程提供环境变量，调用用户空间的可执行文件，简称uevent helper。CONFIG_UEVENT_HELPER_PATH指定了uevent helper的路径。用户控件可以通过把helper路径写入”/sys/kernel/uevent_helper”来指定它的路径。</li>
</ul>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/uevent_env.png"/>

<h3 id="3-Android-uevent"><a href="#3-Android-uevent" class="headerlink" title="3 Android uevent"></a>3 Android uevent</h3><p>从第2部分，我们知道，kernel会通过netlink socket发送uevent消息。Android提供了UEventObserver类来完成这个工作，我们来看一下它的使用和原理。UEventObserver是一个hide的抽象类，使用时需要重写它的onEvent()方法，framework层的BatteryService，HeadsetObserver等都有用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;BatteryService.java*&#x2F;</span><br><span class="line">        &#x2F;&#x2F; watch for invalid charger messages if the invalid_charger switch exists</span><br><span class="line">        if (new File(&quot;&#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;switch&#x2F;invalid_charger&#x2F;state&quot;).exists()) &#123;</span><br><span class="line">            UEventObserver invalidChargerObserver &#x3D; new UEventObserver() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onUEvent(UEvent event) &#123;</span><br><span class="line">                    final int invalidCharger &#x3D; &quot;1&quot;.equals(event.get(&quot;SWITCH_STATE&quot;)) ? 1 : 0;</span><br><span class="line">                    synchronized (mLock) &#123;</span><br><span class="line">                        if (mInvalidCharger !&#x3D; invalidCharger) &#123;</span><br><span class="line">                            mInvalidCharger &#x3D; invalidCharger;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            invalidChargerObserver.startObserving(</span><br><span class="line">                    &quot;DEVPATH&#x3D;&#x2F;devices&#x2F;virtual&#x2F;switch&#x2F;invalid_charger&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>使用比较简单，重写onUEvent()，调用startObserving(）方法即可，调用时，需要传递一个字符串，这个是底层用来检测收到的event是否match观察者的需求。</p>
<h4 id="3-1-startObserving"><a href="#3-1-startObserving" class="headerlink" title="3.1 startObserving"></a>3.1 startObserving</h4><p>每个UEventObserver对应一个线程，首次调用startObserving(）时，启动线程，并调用native方法添加前面的传下来的匹配字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os*&#x2F;</span><br><span class="line">public final void startObserving(String match) &#123;</span><br><span class="line">    if (match &#x3D;&#x3D; null || match.isEmpty()) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;match substring must be non-empty&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final UEventThread t &#x3D; getThread();</span><br><span class="line">    t.addObserver(match, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os*&#x2F;</span><br><span class="line">public void addObserver(String match, UEventObserver observer) &#123;</span><br><span class="line">          synchronized (mKeysAndObservers) &#123;</span><br><span class="line">              mKeysAndObservers.add(match);</span><br><span class="line">              mKeysAndObservers.add(observer);</span><br><span class="line">              nativeAddMatch(match); &#x2F;*参考3.3*&#x2F;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-run"><a href="#3-2-run" class="headerlink" title="3.2 run"></a>3.2 run</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    nativeSetup(); &#x2F;*做一些初始化，见3.5*&#x2F;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        String message &#x3D; nativeWaitForNextEvent();</span><br><span class="line">        if (message !&#x3D; null) &#123;</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, message);</span><br><span class="line">            &#125;</span><br><span class="line">            sendEvent(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动的线程中调用<code>nativeWaitForNextEvent()</code>（参考3.4）接收event，收到message且不为空后调用<code>sendEvent()</code>方法分发给observer。</p>
<h4 id="3-3-nativeAddMatch"><a href="#3-3-nativeAddMatch" class="headerlink" title="3.3 nativeAddMatch"></a>3.3 nativeAddMatch</h4><p>接下来看下native方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_os_UEventObserver.cpp*&#x2F;</span><br><span class="line">static void nativeAddMatch(JNIEnv* env, jclass clazz, jstring matchStr) &#123;</span><br><span class="line">    ScopedUtfChars match(env, matchStr);</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(gMatchesMutex);</span><br><span class="line">    gMatches.add(String8(match.c_str()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的把传下来的match字符串加入gMatches。</p>
<h4 id="3-4-nativeWaitForNextEvent"><a href="#3-4-nativeWaitForNextEvent" class="headerlink" title="3.4 nativeWaitForNextEvent"></a>3.4 nativeWaitForNextEvent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_os_UEventObserver.cpp*&#x2F;</span><br><span class="line">static jstring nativeWaitForNextEvent(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    char buffer[1024];</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int length &#x3D; uevent_next_event(buffer, sizeof(buffer) - 1);</span><br><span class="line">        if (length &lt;&#x3D; 0) &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[length] &#x3D; &#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">        ALOGV(&quot;Received uevent message: %s&quot;, buffer);</span><br><span class="line"></span><br><span class="line">        if (isMatch(buffer, length)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Assume the message is ASCII.</span><br><span class="line">            jchar message[length];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">                message[i] &#x3D; buffer[i];</span><br><span class="line">            &#125;</span><br><span class="line">            return env-&gt;NewString(message, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续调用uevent_next_event()去接收uevent，收到后根据gMatches进行过滤，然后返回。3.2的接口就收到返回消息并分发了。</p>
<h4 id="3-5-nativeSetup"><a href="#3-5-nativeSetup" class="headerlink" title="3.5 nativeSetup"></a>3.5 nativeSetup</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void nativeSetup(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    if (!uevent_init()) &#123;</span><br><span class="line">        jniThrowException(env, &quot;java&#x2F;lang&#x2F;RuntimeException&quot;,</span><br><span class="line">                &quot;Unable to open socket for UEventObserver&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用uevent_init()。</p>
<p>3.3-3.5是native部分，这部分基本上只做过滤工作，初始化和收事件都交给了hardware/libhardware_legacy/uevent.c。</p>
<h4 id="3-6-uevent-init"><a href="#3-6-uevent-init" class="headerlink" title="3.6 uevent_init"></a>3.6 uevent_init</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int uevent_init()</span><br><span class="line">&#123;</span><br><span class="line">    struct sockaddr_nl addr;</span><br><span class="line">    int sz &#x3D; 64*1024;</span><br><span class="line">    int s;</span><br><span class="line"></span><br><span class="line">    memset(&amp;addr, 0, sizeof(addr));</span><br><span class="line">    addr.nl_family &#x3D; AF_NETLINK;</span><br><span class="line">    addr.nl_pid &#x3D; getpid();</span><br><span class="line">    addr.nl_groups &#x3D; 0xffffffff;</span><br><span class="line"></span><br><span class="line">    s &#x3D; socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);</span><br><span class="line">    if(s &lt; 0)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    setsockopt(s, SOL_SOCKET, SO_RCVBUFFORCE, &amp;sz, sizeof(sz));</span><br><span class="line"></span><br><span class="line">    if(bind(s, (struct sockaddr *) &amp;addr, sizeof(addr)) &lt; 0) &#123;</span><br><span class="line">        close(s);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd &#x3D; s;</span><br><span class="line">    return (fd &gt; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里和3.7是用户空间接收netlink socket的关键了，创建套接字，绑定地址。</p>
<h4 id="3-7-uevent-next-event"><a href="#3-7-uevent-next-event" class="headerlink" title="3.7 uevent_next_event"></a>3.7 uevent_next_event</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int uevent_next_event(char* buffer, int buffer_length)</span><br><span class="line">&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        struct pollfd fds;</span><br><span class="line">        int nr;</span><br><span class="line">    </span><br><span class="line">        fds.fd &#x3D; fd;</span><br><span class="line">        fds.events &#x3D; POLLIN;</span><br><span class="line">        fds.revents &#x3D; 0;</span><br><span class="line">        nr &#x3D; poll(&amp;fds, 1, -1);</span><br><span class="line">     </span><br><span class="line">        if(nr &gt; 0 &amp;&amp; (fds.revents &amp; POLLIN)) &#123;</span><br><span class="line">            int count &#x3D; recv(fd, buffer, buffer_length, 0);</span><br><span class="line">            if (count &gt; 0) &#123;</span><br><span class="line">                struct uevent_handler *h;</span><br><span class="line">                pthread_mutex_lock(&amp;uevent_handler_list_lock);</span><br><span class="line">                LIST_FOREACH(h, &amp;uevent_handler_list, list)</span><br><span class="line">                    h-&gt;handler(h-&gt;handler_data, buffer, buffer_length);</span><br><span class="line">                pthread_mutex_unlock(&amp;uevent_handler_list_lock);</span><br><span class="line"></span><br><span class="line">                return count;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; won&#39;t get here</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阻塞在初始化创建的套接字，知道收到uevent消息。</p>
<p>整个过程可以用下图来概括：</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/android_uevent.png"/>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E8%BF%9B%E7%A8%8BID%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="myh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E8%BF%9B%E7%A8%8BID%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">进程ID管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 10:51:08 / 修改时间：10:57:47" itemprop="dateCreated datePublished" datetime="2020-05-31T10:51:08+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>进程在命名空间中有一个唯一的进程ID号，由于进程可能在多个命名空间可见，所以他会有多个PID。进程还有其他的ID：</p>
<ul>
<li>TGID，处于某个线程组的所有进程都有统一的线程组ID。进程task_struct的group_leader指向的进程中包含了TGID的信息，实际上就是group_leader的PID。</li>
<li>PGID，进程组ID。进程组简化了向组的所有成员发信号的操作，用管道连接的进程包含在同一个进程组中。进程task_struct的group_leader指向的进程中包含了PGID的信息。</li>
<li>SID，多个进程组可以合并成一个会话，会话中所有进程有同样的会话ID。进程task_struct的group_leader指向的进程中包含了SID的信息。</li>
</ul>
<p>在内核中，这些ID统一用<code>struct pid</code>，需要注意的是它不仅仅能表示PID，尽管他们同名。后面再详细介绍该数据结构，先来看看各进程(task_struct)是如何会去找到自己的各类型的ID的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel&#x2F;include&#x2F;sched.h&gt;</span><br><span class="line">struct task_struct &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct pid_link  pids[PIDTYPE_MAX];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*kernel&#x2F;include&#x2F;pid.h*&#x2F;</span><br><span class="line">struct pid_link &#123;</span><br><span class="line">    struct hlist_node node;</span><br><span class="line">    struct *pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>task_struct中pids[]数组，针对PID，PGID和SID类型都有一个struct pid_link类型的元素，没有TGID是因为它就是group_leader的PID。struct pid_link的pid成员指向了进程的ID。<br>获取进程的PID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;sched.h&gt;</span><br><span class="line">static inline struct pid *task_pid(struct task_struct *task)</span><br><span class="line">&#123;</span><br><span class="line">    return task-&gt;pids[PIDTYPE_PID].pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取进程的TGID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline struct pid *task_tgid(struct task_struct *task)</span><br><span class="line">&#123;</span><br><span class="line">    return task-&gt;group_leader-&gt;pids[PIDTYPE_PID].pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取进程的PGID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline struct pid *task_pgrp(struct task_struct *task)</span><br><span class="line">&#123;</span><br><span class="line">    return task-&gt;group_leader-&gt;pids[PIDTYPE_PGID].pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取进程的SID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline struct pid *task_session(struct task_struct *task)</span><br><span class="line">&#123;</span><br><span class="line">    return task-&gt;group_leader-&gt;pids[PIDTYPE_SID].pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>struct pid</code>结构的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;pid.h&gt;</span><br><span class="line">struct upid &#123;</span><br><span class="line">    int nr;</span><br><span class="line">    struct pid_namespace *ns;</span><br><span class="line">    struct hlist_node pid_chain;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pid</span><br><span class="line">&#123;</span><br><span class="line">    atomic_t count;</span><br><span class="line">    &#x2F;* 使用该pid的进程的列表 *&#x2F;</span><br><span class="line">    struct hlist_head tasks[PIDTYPE_MAX];</span><br><span class="line">    int level;</span><br><span class="line">    struct upid numbers[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进程ID的管理围绕这两个数据结构展开，tasks数组的元素是散列表头，链接的是所有共享该ID的进程，进程是通过前面struct pid_link中的node链接进来的，这样通过task_struct结构和pid_type(是个enum类型，取值有PID，PGID和SID)可以找到struct pid（前面已经介绍），通过pid_type和pid也可以找到task_struct：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct *pid_task(struct pid *pid, enum pid_type type)</span><br><span class="line">&#123;</span><br><span class="line">    struct task_struct *result &#x3D; NULL;</span><br><span class="line">    if (pid) &#123;</span><br><span class="line">        struct hlist_node *first;</span><br><span class="line">        first &#x3D; rcu_dereference_check(hlist_first_rcu(&amp;pid-&gt;tasks[type]),</span><br><span class="line">                                lockdep_tasklist_lock_is_held());</span><br><span class="line">       if (first)</span><br><span class="line">            result &#x3D; hlist_entry(first, struct task_struct, pids[(type)].node);</span><br><span class="line">    &#125;</span><br><span class="line">    return reuslt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回pid-&gt;tasks链表第一个节点的task_struct，为什么返回第一个节点呢？这里的理解是，要先弄明白为什么会有多个进程共享一个ID呢？因为PGRD对于属于该进程组的所有进程来说都是一样，这样表示PGRD的struct pid就会在tasks链接上多个task_struct，第一个是组长进程？<br>以上都是struct pid和struct task_struct之间的关联，实际上struct pid还维护了数值pid，也就是用户空间所看到的。一个struct pid可能对应多个数值pid，因为linux内核2.6的某个版本之后引入命名空间的概念：</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/namespace.png"/>

<p>如上图所示，尽管系统上有9个进程，但却需要15个PID来表示，因为一个进程可以关联到多个PID。至于那个是“正确”的，则依赖于具体的上下文。命名空间的结构体摘要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;pid_namespace.h&gt;</span><br><span class="line"></span><br><span class="line">struct pid_namespace &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct task_struct *child_reaper;</span><br><span class="line">    ...</span><br><span class="line">    int level;</span><br><span class="line">    struct pid_namespace *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中level用来表示当前命名空间在命名空间层次结构中的深度。初始命名空间的level为0，它的子空间level为1，依此递推。level较高的命名空间中的PID对level较低的命名空间来说是可见的；没个命名空间都有一个进程，作用类似于全局的init进程，init的一个目的是对孤儿进程调用wait4，child_reaper指向子命名空间中承担该功能的进程；parent指针用来把命名空间层次化。<br>前面struct pid结构中还有几个成员没介绍，level用于指明该pid关联的命名空间level的最大值；对于每个命名空间都有一个struct upid结构与其对应，在struct pid结构中形成一个数组numbers。<br>struct upid中nr表示ID的数值(终于找到它了==!)，ns指向该ID所属的命名空间。pid_chain作为一个散列表节点，把upid链接进散列表中，关于该散列表，后面再详述。</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/pidhlist.png"/>

<p>前面struct pid和struct task_struct之间的关系涉及的示意图如上图蓝色部分。struct pid，数值pid和命名空间的示意图如上图黑色部分。<br>由struct pid和struct pid_namespace获取数值pid：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel&#x2F;pid.c&gt;</span><br><span class="line">pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    sturct upid *upid;</span><br><span class="line">    pid_t nr &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    if (pid &amp;&amp; ns-&gt;level &lt;&#x3D; pid-&gt;level) &#123;</span><br><span class="line">        upid &#x3D; &amp;pid-&gt;numbers[ns-&gt;level];</span><br><span class="line">        if (upid-&gt;ns &#x3D;&#x3D; ns)</span><br><span class="line">            nr &#x3D; upid-&gt;nr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由数值pid和struct pid_namespace获取struct pid：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel&#x2F;pid.c&gt;</span><br><span class="line">struct pid * fastcall find_pid_ns(int nr, struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">    struct upid *pnr;</span><br><span class="line">    hlist_for_each_entry_rcu(pnr,</span><br><span class="line">            &amp;pid_hash[pid_hasfn(nr, ns)], pid_chain)</span><br><span class="line">            if (pnr-&gt;nr &#x3D;&#x3D; nr &amp;&amp; pnr-&gt;ns &#x3D;&#x3D; ns)</span><br><span class="line">                return container_of(pnr, struct pid,</span><br><span class="line">                            numbers[ns-&gt;level]);</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了pid.c中的一个全局静态变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static struct hlist_head *pid_hash;</span><br></pre></td></tr></table></figure>

<p>前面提到struct upid的pid_chain作用是把upid链接进散列表中，就是连接到pid_hash的。pid_hash是一个hlist_head数组，它是在pidhash_init()方法中初始化并分配内存的，可以在该方法中找到计算数组大小的方法，通过内核log可以看到实际结果：</p>
<img src="https://pic-1302206658.cos.ap-shanghai.myqcloud.com/hashtable.png"/>

<p>可以看到，该系统中pid_hash数组有4096个元素。<br>upid经过pid_hasfn运算后，插入到pid_hash[pid_hasfn(nr, ns)]散列表，所有经过pid_hasfn运算后值一样的upid通过链表链接起来。<br>内核还提供了很多接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;sched.h&gt;</span><br><span class="line">&#x2F;** the helpers to get the task&#39;s different pids as they are seen</span><br><span class="line">* from various namespaces</span><br><span class="line">*</span><br><span class="line">* task_xid_nr() : global id, i.e. the id seen from the init namespace;</span><br><span class="line">* task_xid_vnr() : virtual id, i.e. the id seen from the pid namespace of</span><br><span class="line">* current.</span><br><span class="line">* task_xid_nr_ns() : id seen from the ns specified;</span><br><span class="line">*</span><br><span class="line">* see also pid_nr() etc in include&#x2F;linux&#x2F;pid.h</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>xid表示pid，pgrp和session，vnr是指从current进程所属的命名空间看task的pid_t是多少，nr_ns会指定命名空间。<br>他们都会调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel&#x2F;pid.c&gt;</span><br><span class="line">pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,</span><br><span class="line">                            struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">         pid_t nr &#x3D; 0;</span><br><span class="line"></span><br><span class="line">         rcu_read_lock();</span><br><span class="line">         if (!ns)</span><br><span class="line">                   ns &#x3D; task_active_pid_ns(current);</span><br><span class="line">         if (likely(pid_alive(task)))</span><br><span class="line">                   nr &#x3D; pid_nr_ns(rcu_dereference(*task_pid_ptr(task, type)), ns);</span><br><span class="line">         rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">         return nr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的xid传递的type不同，vnr传递的ns为NULL，__task_pid_nr_ns会找到current的命令空间。task_active_pid_ns的实现，首先使用前面介绍的task_pid找到他的pid，然后用下面的方法返回pid的命名空间，这里要注意，pid是有一个命名空间数组的，那么返回哪个呢？这里返回的是最底层的，即最后一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;pid.h&gt;</span><br><span class="line">static inline struct pid_namespace *ns_of_pid(struct pid *pid)</span><br><span class="line">&#123;</span><br><span class="line">         struct pid_namespace *ns &#x3D; NULL;</span><br><span class="line">         if (pid)</span><br><span class="line">                   ns &#x3D; pid-&gt;numbers[pid-&gt;level].ns;</span><br><span class="line">         return ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pid.h中的pid_nr和pid_vnr分别返回初始命名空间和current命名空间看的数值pid：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline pid_t pid_nr(struct pid *pid)</span><br><span class="line">&#123;</span><br><span class="line">         pid_t nr &#x3D; 0;</span><br><span class="line">         if (pid)</span><br><span class="line">                   nr &#x3D; pid-&gt;numbers[0].nr;</span><br><span class="line">         return nr;</span><br><span class="line">&#125;</span><br><span class="line">pid_t pid_vnr(struct pid *pid)</span><br><span class="line">&#123;</span><br><span class="line">         return pid_nr_ns(pid, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来理解下vnr，回看前面命名空间的图，父空间的5和子空间的2对应于同一个struct pid实体，如果当前位于子空间，想要获得struct pid在子空间代表的数值pid，就需要调用pid_vnr或者task_xid_vnr。<br>把前面的find_pid_ns()（由数值pid和struct pid_namespace获取struct pid）和pid_task()（通过pid_type和struct pid可以找到task_struct）组合起来，内核提供了find_task_by_pid_ns()接口：由数值pid和struct pid_namespace获取到task_struct，pid_type为PIDTYPE_PID。还提供了find_task_by_vpid()，参数只有数值pid，命名空间由current算出。<br>这里再来回顾下pid_task()接口，前面说了它返回struct pid-&gt;tasks链表中第一个节点，假设这里传递的是PTYPE_PGID类型，数值为4，那么进程组id为4的进程本来就不止一个；但如果传递的是PTYPE_PID类型，是不是就只有一个了呢？（个人猜想），所以这里提供的find_task_xxx接口直接默认了pid_type是PTYPE_PID。在旧版的内核版本中，还提供了find_task_by_pid_type_ns，允许指定pid_tyoe，新版找不到这个接口了，是认为没有意义了吗？</p>
<h2 id="生成唯一的PID"><a href="#生成唯一的PID" class="headerlink" title="生成唯一的PID"></a>生成唯一的PID</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">kernel&#x2F;pid.c</span><br><span class="line">struct pid *alloc_pid(struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">    struct pid *pid;</span><br><span class="line">    enum pid_type type;</span><br><span class="line">    int i, nr;</span><br><span class="line">    struct pid_namespace *tmp;</span><br><span class="line">    struct upid *upid;</span><br><span class="line">    ...</span><br><span class="line">    tmp &#x3D; ns;</span><br><span class="line">    for (i &#x3D; ns-&gt;level; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        nr &#x3D; alloc_pidmap(tmp);</span><br><span class="line">        ...</span><br><span class="line">        pid-&gt;numbers[i].nr &#x3D; nr;</span><br><span class="line">        pid-&gt;numbers[i].ns &#x3D; tmp;</span><br><span class="line">        tmp &#x3D; tmp-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    pid-&gt;level &#x3D; ns-&gt;level;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; ns-&gt;level; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        upid &#x3D; &amp;pid-&gt;numbers[i];</span><br><span class="line">        hlist_add_head_rcu(&amp;upid-&gt;pid_chain,</span><br><span class="line">        &amp;pid_hash[pid_hashfn(upid-&gt;nr, upid-&gt;ns)]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 pid_namespace有一个成员叫pid_map，他用位图的方式记录了PID的分配情况，已分配的PID对应的位为1，分配新PID时就是找位为0的是第几位。分配和释放PID由alloc_pidmap()和free_pidmap()方法提供。<br>2 从当前命名空间开始，依次向上遍历所有的命名空间，在各个命名空间分配数值ID，并更新对应的struct pid-&gt;numbers数组，把数值ID存在数组元素，同时把他的指针指向命名空间。<br>3 更新pid-&gt;level。<br>4 把struct pid的numbers数组加入到pid_hash进行管理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="myh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/LeetCode/" class="post-title-link" itemprop="url">LeetCode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 10:49:18 / 修改时间：10:56:45" itemprop="dateCreated datePublished" datetime="2020-05-31T10:49:18+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1207-Unique-Number-of-Occurrences"><a href="#1207-Unique-Number-of-Occurrences" class="headerlink" title="1207  Unique Number of Occurrences"></a>1207  <a href="https://leetcode.com/problems/unique-number-of-occurrences/" target="_blank" rel="noopener">Unique Number of Occurrences</a></h2><p>简单直接的思路：准备两个数组，一个存输入数组中出现的数字叫nums，一个对应的存该数字出现的次数叫times。遍历输入数组时，先在nums中找，找到则对应的times加1，找不到，nums新增该数字，times新增其次数，初始值为1。</p>
<p>遍历结束，times数组先排序，然后遍历看其是否有重复数字。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; times;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite = arr.<span class="built_in">begin</span>(); ite != arr.<span class="built_in">end</span>(); ite++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator result = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), *ite);</span><br><span class="line">            <span class="keyword">if</span> (result == nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                nums.push_back(*ite);</span><br><span class="line">                times.push_back(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = result - nums.<span class="built_in">begin</span>();</span><br><span class="line">                times[index]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(times.<span class="built_in">begin</span>(), times.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> old_time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite = times.<span class="built_in">begin</span>(); ite != times.<span class="built_in">end</span>(); ite++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*ite == old_time) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                old_time = *ite;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看了别人的方法，很多是结合了map和set，还有用unsorted_map的，是时候复习一下了。</p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>map和set都属于STL中的关联式容器(associattive containers)。</p>
<p>标准的STL关联式容器分为set和map两大类，以及他们的衍生体multiset和multimap，他们的底层机制都是以<strong>RB-tree（红黑树）</strong>完成。</p>
<p>还有一种底层数据结构hashtable，以他为底层机制，实现了hash_set，hash_map，hash_multiset，hash_multimap。</p>
<h4 id="1-1-红黑树"><a href="#1-1-红黑树" class="headerlink" title="1.1 红黑树"></a>1.1 红黑树</h4><p>二叉搜索树的定义：任何节点的键值一定大于其左子树中所有节点的键值，小于其右子树中所有节点的键值。二叉搜索树的缺点：极端情况可能导致线性搜索，如所有节点都只有右子节点。</p>
<p>平衡二叉搜索树解决了二叉搜索树的问题，RB-tree属于平衡二叉搜索树的一种，红黑树的定义：</p>
<ol>
<li>每个节点不是红色就是黑色。</li>
<li>根节点为黑色。</li>
<li>如果节点为红色，其子节点必须为黑。</li>
<li>任一节点至NULL（树尾端）的任何路径，所含黑节点数必须相同。</li>
</ol>
<h3 id="2-c-map"><a href="#2-c-map" class="headerlink" title="2 c++ map"></a>2 c++ map</h3><h3 id="3-c-set"><a href="#3-c-set" class="headerlink" title="3 c++ set"></a>3 c++ set</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/28/%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="myh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/28/%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-28 22:10:11 / 修改时间：22:40:12" itemprop="dateCreated datePublished" datetime="2020-05-28T22:10:11+08:00">2020-05-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="std-move-c-11"><a href="#std-move-c-11" class="headerlink" title="std::move (c++11)"></a>std::move (c++11)</h2><p>一个对象“moved from”另一个对象，<strong>避免了拷贝的产生</strong>，但被move的对象处于valid but unspecified状态。move的语义是把一个已存在的资源转移到一个新的目的地，而copy需要重新创建一个资源。详见<a href="https://en.cppreference.com/w/cpp/utility/move" target="_blank" rel="noopener">链接</a>。</p>
<h2 id="std-map-lt-Key-T-Compare-Allocator-gt-emplace-c-11"><a href="#std-map-lt-Key-T-Compare-Allocator-gt-emplace-c-11" class="headerlink" title="std::map&lt;Key,T,Compare,Allocator&gt;::emplace (c++11)"></a>std::map&lt;Key,T,Compare,Allocator&gt;::emplace (c++11)</h2><p>向map插入元素，并且避免产生不必要的临时变量。<a href="https://en.cppreference.com/w/cpp/container/map/emplace" target="_blank" rel="noopener">参考链接</a>。</p>
<h2 id="move构造函数和move赋值运算符（c-11）"><a href="#move构造函数和move赋值运算符（c-11）" class="headerlink" title="move构造函数和move赋值运算符（c++11）"></a>move构造函数和move赋值运算符（c++11）</h2><p> 如果类没有定义构造函数，c++会隐含的定义一些构造函数，包括move函数。move构造函数长这样：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C::C(C&amp;&amp; other); <span class="comment">//C++11 move constructor</span></span><br></pre></td></tr></table></figure>

<p>  它不分配新的资源，而是从其他地方拿取资源。例如：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryPage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">char</span> * buf;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    MemoryPage(MemoryPage&amp;&amp; other): <span class="built_in">size</span>(<span class="number">0</span>), buf(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pilfer other's resource</span></span><br><span class="line">        <span class="built_in">size</span>=other.<span class="built_in">size</span>;</span><br><span class="line">        buf=other.buf; <span class="comment">//没有分配buffer！直接指向别人的buffer。</span></span><br><span class="line">        <span class="comment">// reset other</span></span><br><span class="line">        other.<span class="built_in">size</span>=<span class="number">0</span>;</span><br><span class="line">        other.buf=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  move赋值运算符长这样：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C&amp; C::<span class="keyword">operator</span>=(C&amp;&amp; other);<span class="comment">//C++11 move assignment operator</span></span><br></pre></td></tr></table></figure>
<p>  move赋值运算符类似于拷贝构造，不同的是它“偷取”别人的资源时要先释放自己的。例子：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MemoryPage&amp; MemoryPage::<span class="keyword">operator</span>=(MemoryPage&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>!=&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// release the current object's resources</span></span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="built_in">size</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// pilfer other's resource</span></span><br><span class="line">        <span class="built_in">size</span>=other.<span class="built_in">size</span>;</span><br><span class="line">        buf=other.buf;</span><br><span class="line">        <span class="comment">// reset other</span></span><br><span class="line">        other.<span class="built_in">size</span>=<span class="number">0</span>;</span><br><span class="line">        other.buf=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  怎么才能调用到新的move函数呢？标准库函数，如vector::push_back()重载了两个版本，对于左值参数使用const T&amp;作为参数，对于右值使用const T&amp;&amp;作为参数：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;MemoryPage&gt; vm;</span><br><span class="line"></span><br><span class="line">vm.push_back(MemoryPage(<span class="number">1024</span>)); <span class="comment">//calls push_back(T&amp;&amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="function">MemoryPage <span class="title">mp1</span><span class="params">(<span class="number">1024</span>)</span></span>;<span class="comment">//lvalue</span></span><br><span class="line">vm.push_back(mp); <span class="comment">//push_back(const T&amp;)</span></span><br></pre></td></tr></table></figure>
<p>  push_back(T&amp;&amp;)的实现就是move的方式，它会调用MemoryPage的move构造函数。对于左值，也可以转换成右值引用或者使用新的标准函数std::move()，然后调用push_back(T&amp;&amp;)：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.push_back(<span class="keyword">static_cast</span>&lt;MemoryPage&amp;&amp;&gt;(mp));<span class="comment">//calls push_back(T&amp;&amp;)</span></span><br><span class="line"></span><br><span class="line">vm.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(mp));<span class="comment">//calls push_back(T&amp;&amp;)</span></span><br></pre></td></tr></table></figure><br>  <a href="https://smartbear.com/blog/develop/c11-tutorial-introducing-the-move-constructor-and/" target="_blank" rel="noopener">参考链接</a>（对于英语渣很友好==！）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Contentprovider/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="myh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/25/Contentprovider/" class="post-title-link" itemprop="url">Contentprovider</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 21:59:14" itemprop="dateCreated datePublished" datetime="2020-05-25T21:59:14+08:00">2020-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">myh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">myh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
